先看第一次执行的结果:

PID为2236的父进程创建了一个PID为2237的子进程

但是这里 子进程的父进程 PID变成了 1

我们知道 ,一个进程的父进程负责处理该进程的状态信息

但此时 父进程 先于 子进程结束,

该进程退出的信息无法被处理,

变成了 孤儿进程,操作系统统一为其找到一个 PID为 1 的 init “爸爸”,接管此进程

再来看第二次的结果: 子进程先结束,然后父进程再结束,所以父子关系没有被改变

所以fork并不保证父子进程的执行顺序
